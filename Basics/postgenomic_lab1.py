# -*- coding: utf-8 -*-
"""Postgenomic_Lab1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DX0dotLYRiTC25kjcZruTICuDGsXf8zd

#Postgenomic - Lab1
 by Maria G. Jimenez
 Sept/2/2025
"""

import numpy as np

A = [[1,3,7],[5,	1,	2], [0,	1,	2]]
B = [[2,	0,	1,], [4,	1,	3], [3,	5,	2]]

print(A)
print(B)

"""Part 2.1 (Python Programming):
Python does not have a matrix datatype, the closest datatype for this are lists or dataframes. Create your own function that reads in two matrices (list or dataframe) that return the product of these two. *Hint: Triple for loop *

"""

def mult_matrices(X,Y):
  X1 = np.array(X)
  X2 = np.array(Y)
  if (len(X1.shape)==2 and len(X2.shape)==2 and X1.shape[1] == X2.shape[0]):
    C = np.zeros((X1.shape[0], X2.shape[1]), np.int64)
    mult = 1
    for i in range(X1.shape[0]):
      for k in range(X2.shape[1]):
        for j in range(X1.shape[1]):
          C[i,k] += X1[i,j] * X2[j,k]

  else:
    raise ValueError("We expect two 2D-matrix with dimensions nxm and mxt, respectively.")
  return C

print(mult_matrices(A,B))

"""Part 2.2 (Python Programming):
A package within python, numpy, has a function that calculates the (dot) product between two matrices.

Download/Install this package. Calculate the run time between your matrix multiplication function from Part 2 and the package from numpy. Which is the fastest method, your defined function or the built-in package? In your opinion, why do you think that is?

"""

def dot_function(A,B):
  C = np.dot(np.array(A), np.array(B))
  return C
print(dot_function(A,B))

import time

start = time.perf_counter()
temp = mult_matrices(A,B)
elapsed_time1 = time.perf_counter() - start
print('elapsed time using for-loops', elapsed_time1,'secs')

start = time.perf_counter()
temp = dot_function(A,B)
elapsed_time2 = time.perf_counter() -start
print('elapsed time using numpy.dot() ', elapsed_time2,'secs')

print('ratio',elapsed_time1/elapsed_time2)